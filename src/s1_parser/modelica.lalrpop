// Based on Modelica 3.7-dev Specification
use crate::s0_lexer::tokens::{Token, LexicalError};
use crate::s1_parser::ast::node;
use crate::s1_parser::ast::part;
use crate::s1_parser::ast::fragment;

grammar(context: &mut part::ParserContext);

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// LALRPOP macros
SeparatedList<T, Str>: Vec<T> = {
    <mut v:(<T> Str)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SeparatedListMinOne<T, Str>: Vec<T> = {
    <e:T> <v:(Str <T>)*>  => {
        let mut res = vec![e];
        res.extend(v);
        res
    }
};

TerminatedList<T, Str>: Vec<T> = {
    <v:(<T> Str)*> => v

};

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 2.3.3 Modelica Keywords

extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        // keywords
        "algorithm" => Token::KeywordAlgorithm,
        "and" => Token::KeywordAnd,
        "annotation" => Token::KeywordAnnotation,
        "block" => Token::KeywordBlock,
        "break" => Token::KeywordBreak,
        "class" => Token::KeywordClass,
        "connect" => Token::KeywordConnect,
        "connector" => Token::KeywordConnector,
        "constant" => Token::KeywordConstant,
        "constrainedby" => Token::KeywordConstrainedby,
        "der" => Token::KeywordDer,
        "discrete" => Token::KeywordDiscrete,
        "each" => Token::KeywordEach,
        "else" => Token::KeywordElse,
        "elseif" => Token::KeywordElseif,
        "elsewhen" => Token::KeywordElsewhen,
        "encapsulated" => Token::KeywordEncapsulated,
        "end" => Token::KeywordEnd,
        "enumeration" => Token::KeywordEnumeration,
        "equation" => Token::KeywordEquation,
        "expandable" => Token::KeywordExpandable,
        "extends" => Token::KeywordExtends,
        "external" => Token::KeywordExternal,
        "final" => Token::KeywordFinal,
        "flow" => Token::KeywordFlow,
        "for" => Token::KeywordFor,
        "function" => Token::KeywordFunction,
        "if" => Token::KeywordIf,
        "import" => Token::KeywordImport,
        "impure" => Token::KeywordImpure,
        "in" => Token::KeywordIn,
        "initial" => Token::KeywordInitial,
        "inner" => Token::KeywordInner,
        "input" => Token::KeywordInput,
        "loop" => Token::KeywordLoop,
        "model" => Token::KeywordModel,
        "not" => Token::KeywordNot,
        "operator" => Token::KeywordOperator,
        "or" => Token::KeywordOr,
        "outer" => Token::KeywordOuter,
        "output" => Token::KeywordOutput,
        "package" => Token::KeywordPackage,
        "parameter" => Token::KeywordParameter,
        "partial" => Token::KeywordPartial,
        "protected" => Token::KeywordProtected,
        "public" => Token::KeywordPublic,
        "pure" => Token::KeywordPure,
        "record" => Token::KeywordRecord,
        "redeclare" => Token::KeywordRedeclare,
        "replaceable" => Token::KeywordReplaceable,
        "return" => Token::KeywordReturn,
        "stream" => Token::KeywordStream,
        "then" => Token::KeywordThen,
        "type" => Token::KeywordType,
        "when" => Token::KeywordWhen,
        "while" => Token::KeywordWhile,
        "within" => Token::KeywordWithin,

        // other lexical tokens
        "IDENT" => Token::Identifier(<String>),
        "STRING" => Token::String(<String>),
        "UNSIGNED-INTEGER" => Token::UnsignedInteger(<String>),
        "UNSIGNED-REAL" => Token::UnsignedReal(<String>),
        "boolean" => Token::Boolean(<bool>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ":=" => Token::Assign,
        "=" => Token::Equal,
        ";" => Token::Semicolon,
        "." => Token::Period,
        ":" => Token::Colon,
        "," => Token::Comma,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
        "^" => Token::OperatorExp,

        ".+" => Token::OperatorElemAdd,
        ".-" => Token::OperatorElemSub,
        ".*" => Token::OperatorElemMul,
        "./" => Token::OperatorElemDiv,
        ".^" => Token::OperatorElemExp,

        "<" => Token::OperatorLessThan,
        "<=" => Token::OperatorLessThanOrEqual,
        ">" => Token::OperatorGreaterThan,
        ">=" => Token::OperatorGreaterThanOrEqual,
        "==" => Token::OperatorEqual,
        "<>" => Token::OperatorNotEqual,
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.1 Stored Definition â€“ Within
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… stored-definition :
//âœ…    [ within [ name ] ";" ]
//âœ…    { [ final ] class-definition ";" }
pub StoredDefinition: node::StoredDefinition = {
    <left: @L>
    <within: ("within" <Name> ";")?>
    <classes:TerminatedList<ClassDefinitionWithFinal, ";">>
    <right: @R> => {
        let id = context.new_id();
        let node_data = part::NodeData::new(id, left, right);
        node::StoredDefinition {
            node_data,
            classes: classes.into_iter()
                .map(|class| (class.name.clone(), class)).collect(),
            within,
            rumoca_parser_version: "".to_string(),
            rumoca_parser_git: "".to_string(),
            model_md5: "".to_string(),
        }
    }
}

ClassDefinitionWithFinal: node::ClassDefinition = {
    <is_final: "final"?> <mut class: ClassDefinition> => {
        class.flags.is_final = is_final.is_some();
        class
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.2 Class Definition
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… class-definition :
//âœ…    [ encapsulated ] class-prefixes class-specifier
pub ClassDefinition: node::ClassDefinition = {
    <left: @L> <encapsulated: "encapsulated"?>
    <prefixes: ClassPrefixes>
    <specifier: ClassSpecifier> <right: @R> => {
        let id = context.new_id();
        let (name, modification, description, composition) = match specifier {
            fragment::ClassSpecifier::Long(spec) => (spec.name, Vec::new(), spec.description, spec.composition),
            fragment::ClassSpecifier::Extends(spec) => (spec.name, spec.modification, spec.description, spec.composition),
            fragment::ClassSpecifier::Empty => panic!("Empty ClassSpecifier"),
        };

        let mut def = node::ClassDefinition {
            node_data: part::NodeData::new(id, left, right),
            name,
            class_type: prefixes.class_type,
            flags: part::ClassFlags {
                encapsulated: encapsulated.is_some(),
                partial: prefixes.is_partial,
                ..Default::default()
            },
            modification,
            description,
            ..Default::default()
        };

        for part in composition {
            match part {
                fragment::CompositionPart::ElementList(list) => {
                    for element in list.elements {
                        match element {
                            fragment::Element::ImportClause(import) => {
                                def.imports.push(import);
                            }
                            fragment::Element::ExtendsClause(extends) => {
                                def.extends.push(extends.type_specifier);
                            }
                            fragment::Element::ClassDefinition(class) => {
                                def.classes.insert(class.name.clone(), class);
                            }
                            fragment::Element::ComponentClause(components) => {
                                for mut comp in components {
                                    comp.visibility = list.visibility.clone();
                                    def.components.insert(comp.name.clone(), comp);
                                }
                            }
                            fragment::Element::Empty => {}
                        }
                    }
                },
                fragment::CompositionPart::AlgorithmSection(sec) => {
                    if sec.initial {
                        def.initial_algorithms.push(sec.statements);
                    } else {
                        def.algorithms.push(sec.statements);
                    }
                }
                fragment::CompositionPart::EquationSection(sec) => {
                    if sec.initial {
                        def.initial_equations.extend(sec.equations);
                    } else {
                        def.equations.extend(sec.equations);
                    }
                }
                _ => {}
            }
        }

        def
    }
}
//âœ… class-prefixes :
//âœ…    [ partial ]
//âœ…    ( class
//âœ…      | model
//âœ…      | [ operator ] record
//âœ…      | block
//âœ…      | [ expandable ] connector
//âœ…      | type
//âœ…      | package
//âœ…      | [ pure | impure ] [ operator ] function
//âœ…      | operator
//âœ…    )
ClassPrefixes: fragment::ClassPrefixes = {
    <left: @L> <partial: "partial"?> <class_type: ClassType> <right: @R> => {
        fragment::ClassPrefixes {
            is_partial: partial.is_some(),
            class_type,
        }
    }
}

pub ClassType: part::ClassType = {
    "class" => part::ClassType::Class,
    "model" => part::ClassType::Model,
    "record" => part::ClassType::Record,
    "operator" "record" => part::ClassType::OperatorRecord,
    "block" => part::ClassType::Block,
    "expandable" "connector" => part::ClassType::ExpandableConnector,
    "connector" => part::ClassType::Connector,
    "type" => part::ClassType::Type,
    "package" => part::ClassType::Package,
    "pure" "function" => part::ClassType::PureFunction,
    "impure" "function" => part::ClassType::ImpureFunction,
    "operator" "function" => part::ClassType::OperatorFunction,
    "function" => part::ClassType::Function,
    "operator" => part::ClassType::Operator,
}

//âœ… class-specifier :
//âœ…    long-class-specifier
//ğŸŸ¥     | short-class-specifier
//ğŸŸ¥     | der-class-specifier
pub ClassSpecifier: fragment::ClassSpecifier = {
    <spec: ClassSpecifierLong> => fragment::ClassSpecifier::Long(spec),
    <spec: ClassSpecifierExtends> => fragment::ClassSpecifier::Extends(spec),
}

pub IDENT: String = {
    <ident: "IDENT"> => ident,
}

//âœ… long-class-specifier :
//âœ…    IDENT description-string composition end IDENT
//âœ…    | extends IDENT [ class-modification ] description-string composition end IDENT
pub ClassSpecifierLong: fragment::ClassSpecifierLong = {
    <name: IDENT>
    <description: DescriptionString>
    <composition: Composition>
    "end"
    <name_end: IDENT> => {
        fragment::ClassSpecifierLong {
            name,
            description,
            composition,
            name_end,
        }
    }
}

pub ClassSpecifierExtends: fragment::ClassSpecifierExtends = {
    "extends" <name: IDENT>
    <modification: ModificationClass?>
    <description: DescriptionString>
    <composition: Composition>
    "end" <name_end: IDENT> => {
        fragment::ClassSpecifierExtends {
            name,
            modification: modification.unwrap_or(Vec::new()),
            description,
            composition,
            name_end,
        }
    }
}


//ğŸŸ¥ short-class-specifier :
//ğŸŸ¥    IDENT "=" base-prefix type-specifier [ array-subscripts ] [ class-modification ] description
//ğŸŸ¥    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description

//ğŸŸ¥ der-class-specifier :
//ğŸŸ¥    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description

//ğŸŸ¥ base-prefix :
//ğŸŸ¥    [ input | output ]

//ğŸŸ¥ enum-list :
//ğŸŸ¥    enumeration-literal { "," enumeration-literal }

//ğŸŸ¥ enumeration-literal :
//ğŸŸ¥    IDENT description

//âœ… composition :
//âœ…    element-list
//âœ…    { public element-list
//âœ…      | protected element-list
//âœ…      | equation-section
//âœ…      | algorithm-section
//âœ…    }
//ğŸŸ¥    [ external [ language-specification ]
//ğŸŸ¥      [ external-function-call ] [ annotation-clause ] ";"
//ğŸŸ¥    ]
//ğŸŸ¥    [ annotation-clause ";" ]
pub Composition: Vec<fragment::CompositionPart> = {
    <first:ElementList>
    <remaining: CompositionPart*>
    => {
        let mut v = Vec::new();
        v.push(fragment::CompositionPart::ElementList(fragment::ElementList {
            visibility: part::Visibility::Public,
            elements: first,
        }));
        v.extend(remaining);
        v
    }
}

pub CompositionPart: fragment::CompositionPart = {
    <comp: AlgorithmSection> => fragment::CompositionPart::AlgorithmSection(comp),
    <comp: ElementListWithVisibility> => fragment::CompositionPart::ElementList(comp),
    <comp: EquationSection> => fragment::CompositionPart::EquationSection(comp),
}

pub ElementListWithVisibility: fragment::ElementList = {
    <visibility:Visibility> <elements: ElementList> => {
        let id = context.new_id();
        fragment::ElementList {
            visibility,
            elements,
        }
    }
}

pub Visibility: part::Visibility = {
    "public" => part::Visibility::Public,
    "protected" => part::Visibility::Protected,
}

//âœ… language-specification :
//âœ…    STRING
pub LanguageSpecification: String = {
    <string:"STRING"> => string 
}
//ğŸŸ¥ external-function-call :
//ğŸŸ¥    [ component-reference "=" ] IDENT "(" [ expression-list ] ")"

//âœ… element-list :
//âœ…    { element ";" }
pub ElementList: Vec<fragment::Element> = {
    <elements:TerminatedList<Element, ";">> => elements
}

//âœ… element :
//âœ…    import-clause
//âœ…    | extends-clause
//âœ…    | [ redeclare ] [ final ] [ inner ] [ outer ] (
//âœ…        class-definition
//âœ…        | component-clause
//âœ…        | replaceable (
//âœ…          class-definition
//âœ…          | component-clause)
//ğŸŸ¥        [ constraining-clause description ])
pub ElementFlags : part::ElementFlags = {
    <redeclare:"redeclare"?>
    <is_final:"final"?>
    <inner:"inner"?>
    <outer:"outer"?>
    <replaceable:"replaceable"?> => {
        part::ElementFlags {
            redeclare: redeclare.is_some(),
            is_final: is_final.is_some(),
            inner: inner.is_some(),
            outer: outer.is_some(),
            replaceable: replaceable.is_some(),
        }
    }
}

pub Element : fragment::Element = {
    <elem: ElementComponentClause> => fragment::Element::ComponentClause(elem),
    <elem: ClassDefinition> => fragment::Element::ClassDefinition(elem),
    <elem: ExtendsClause> => fragment::Element::ExtendsClause(elem),
}

pub ElementComponentClause : Vec<node::ComponentDeclaration> = {
    <left: @L> <flags: ElementFlags> <mut components: ComponentClause> <right: @R> => {
        for comp in &mut components {
            comp.flags.replaceable |= flags.replaceable;
            comp.flags.redeclare |= flags.redeclare;
            comp.flags.is_final |= flags.is_final;
            comp.flags.inner |= flags.inner;
            comp.flags.outer |= flags.outer;
        }
        components
    },
}

pub ElementClassDefinition : node::ClassDefinition = {
    <left: @L> <flags: ElementFlags> <mut def: ClassDefinition> <right: @R>  => {
        def.flags.redeclare |= flags.redeclare;
        def.flags.is_final |= flags.is_final;
        def.flags.inner |= flags.inner;
        def.flags.outer |= flags.outer;
        def.flags.replaceable |= flags.replaceable;
        def.node_data.span = (left, right);
        def
    },
}

//âœ… import-clause :
//âœ…    import
//âœ…    ( IDENT "=" name
//ğŸŸ¥      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ])
//âœ…    description

pub ImportClause : node::ImportClause = {
    // qualified import
    <left: @L> "import" <name: Name> <description: Description> <right: @R> => {
        let id = context.new_id();
        node::ImportClause {
            node_data: part::NodeData::new(id, left, right),
            alias: "".to_string(),
            name,
            description,
        }
    },
    // unqualified import
    // "import" <name: Name> ".*" <description: Description> => {
    //     fragment::Element::ImportClause {
    //         alias: None,
    //         name,
    //     }
    // },
    // renaming qualified import
    // "import" <alias:IDENT> "=" <name: Name> <description: Description> => {
    //     fragment::Element::ImportClause {
    //         alias: None,
    //         name,
    //     }
    // },
    // multiple definition import
    // "import" <name:Name> "." "{" SeparatedListMinOne<IDENT, ","> "}"=> {
    //     fragment::Element::ImportClause {
    //         alias: None,
    //         name,
    //     }
    // }
}

//âœ… import-list :
//âœ…    IDENT { "," IDENT }
// Note: flattened into import-clause


// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.3 Extends
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… extends-clause :
//âœ…    extends type-specifier
//ğŸŸ¥    [ class-or-inheritance-modification ]
//ğŸŸ¥    [ annotation-clause ]
pub ExtendsClause: node::ExtendsClause = {
    "extends"
    <left: @L> <type_specifier: TypeSpecifier> <right: @R> => {
        let id = context.new_id();
        node::ExtendsClause {
            node_data: part::NodeData::new(id, left, right),
            type_specifier,
        }
    }
}

//ğŸŸ¥ constraining-clause :
//ğŸŸ¥    constrainedby type-specifier [ class-modification ]

//ğŸŸ¥ class-or-inheritance-modification :
//ğŸŸ¥    "(" [ argument-or-inheritance-modification-list ] ")"

//ğŸŸ¥ argument-or-inheritance-modification-list :
//ğŸŸ¥     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }

//ğŸŸ¥ inheritance-modification :
//ğŸŸ¥     break ( connect-equation | IDENT )

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.4 Component Clause
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… component-clause :
//âœ…    type-prefix type-specifier [ array-subscripts ] component-list
pub ComponentClause: Vec<node::ComponentDeclaration> = {
    <type_prefix: TypePrefix>
    <type_specifier: TypeSpecifier>
    <array_subscripts: ArraySubscripts?>
    <mut components: ComponentList> => {
        for comp in &mut components {
            comp.type_specifier = type_specifier.clone();
            comp.causality = type_prefix.causality.clone();
            comp.variability = type_prefix.variability.clone();
            comp.connection = type_prefix.connection.clone();
            if let Some(ref subs) = array_subscripts {
                comp.array_subscripts = subs.clone();
            }
        }
        components
    }
}

//âœ… type-prefix :
//âœ…    [ flow | stream ]
//âœ…    [ discrete | parameter | constant ]
//âœ…    [ input | output ]
pub TypePrefix: fragment::TypePrefix = {
    <left: @L> <connection: Connection?>
    <variability: Variability?>
    <causality: Causality?> <right: @R> => {
        let id = context.new_id();
        fragment::TypePrefix {
            connection: connection.unwrap_or(part::Connection::Empty),
            variability: variability.unwrap_or(part::Variability::Empty),
            causality: causality.unwrap_or(part::Causality::Empty),
        }
    }
}
pub Connection: part::Connection = {
    "flow" => part::Connection::Flow,
    "stream" => part::Connection::Stream,
}
pub Variability: part::Variability = {
    "discrete" => part::Variability::Discrete,
    "parameter" => part::Variability::Parameter,
    "constant" => part::Variability::Constant,
}
pub Causality: part::Causality = {
    "input" => part::Causality::Input,
    "output" => part::Causality::Output,
}
//âœ… component-list :
//âœ…    component-declaration { "," component-declaration }
pub ComponentList: Vec<node::ComponentDeclaration> = {
    <components: SeparatedList<ComponentDeclaration, ",">> => {
        components
    }
}
//âœ… component-declaration :
//âœ…    declaration [ condition-attribute ] description
pub ComponentDeclaration: node::ComponentDeclaration = {
    <left: @L> <declaration: Declaration>
    <condition_attribute: ConditionAttribute?>
    <description: Description> <right: @R>
    => {
        let id = context.new_id();
        node::ComponentDeclaration{
            node_data: part::NodeData::new(id, left, right),
            name: declaration.name,
            array_subscripts: declaration.array_subscripts,
            modification: declaration.modification,
            condition_attribute,
            description,
            ..Default::default()
        }
    }
}
//âœ… condition-attribute :
//âœ…    if expression
pub ConditionAttribute: node::Expression = {
    "if" <cond: Expression> => cond
}
//âœ… declaration :
//âœ…    IDENT [ array-subscripts ] [ modification ]
pub Declaration: fragment::Declaration = {
    <name: IDENT>
    <array_subscripts:ArraySubscripts?>
    <modification:Modification?> => {
        let id = context.new_id();
        fragment::Declaration {
            name,
            array_subscripts: array_subscripts.unwrap_or(Vec::new()),
            modification,
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.5 Modification
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… modification :
//âœ…    class-modification [ "=" modification-expression ]
//âœ…    | "=" modification-expression
pub Modification: node::Modification = {
    <left: @L> <args: ModificationClass> <expr: ("=" <ModExpr>)?> <right: @R> => {
        let id = context.new_id();
        node::Modification::Class(node::ModificationClass {
            node_data: part::NodeData::new(id, left, right),
            args,
            expr,
        })
    },
    "=" <expr: ModExpr> => {
        node::Modification::Expression(expr)
    },
}

//âœ… modification-expression :
//âœ…    expression
//âœ…    | break
pub ModExpr: node::ModExpr = {
    <expr: Expression> => {
        node::ModExpr::Expression(expr)
    },
    <left: @L> "break" <right: @R>=> {
        let id = context.new_id();
        node::ModExpr::Break(node::ModExprBreak {
            node_data: part::NodeData::new(id, left, right),
        })
    }
}

//âœ… class-modification :
//âœ…    "(" [ argument-list ] ")"
pub ModificationClass: Vec<node::Argument> = {
    "(" <args: SeparatedList<Argument, ",">> ")" => args
}

//âœ… argument-list :
//âœ…    argument { "," argument }
// NOTE: flattend into class-modification above

//ğŸŸ¨ argument :
//ğŸŸ¨    element-modification-or-replaceable
//ğŸŸ¥    | element-redeclaration
pub Argument: node::Argument = {
    <left: @L> <each: "each"?> <is_final: "final"?> <name: Name>
    <modification: Modification?> <description: Description> <right: @R> => {
        let id = context.new_id();
        node::Argument::Modification(node::ArgumentModification {
            node_data: part::NodeData::new(id, left, right),
            name,
            modification,
            description,
            each: each.is_some(),
            is_final: is_final.is_some(),
        })
    },
}

//ğŸŸ¥ element-modification-or-replaceable :
//ğŸŸ¥    [ each ] [ final ] ( element-modification | element-replaceable )

//ğŸŸ¨ element-modification :
//ğŸŸ¨    name [ modification ] description-string

//ğŸŸ¥ element-redeclaration :
//ğŸŸ¥    redeclare [ each ] [ final ]
//ğŸŸ¥    ( short-class-definition | component-clause1 | element-replaceable )

//ğŸŸ¥ element-replaceable :
//ğŸŸ¥    replaceable ( short-class-definition | component-clause1 )
//ğŸŸ¥    [ constraining-clause ]

//âœ… component-clause1 :
//âœ…    type-prefix type-specifier component-declaration1
pub ComponentClause1: node::ComponentDeclaration = {
    <type_prefix: TypePrefix>
    <type_specifier: TypeSpecifier>
    <component_declaration1: ComponentDeclaration1> => {
        let mut comp = component_declaration1;
        comp.type_specifier = type_specifier;
        comp.causality = type_prefix.causality;
        comp.variability = type_prefix.variability;
        comp.connection = type_prefix.connection;
        comp
    }
}

//âœ… component-declaration1 :
//âœ…    declaration description
pub ComponentDeclaration1: node::ComponentDeclaration = {
    <left: @L> <declaration: Declaration>
    <description: Description> <right: @R> => {
        let id = context.new_id();
        node::ComponentDeclaration {
            node_data: part::NodeData::new(id, left, right),
            name: declaration.name,
            array_subscripts: declaration.array_subscripts,
            modification: declaration.modification,
            condition_attribute: None,
            description,
            ..Default::default()
        }
    }
}

//ğŸŸ¥ short-class-definition :
//ğŸŸ¥    class-prefixes short-class-specifier

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.6 Equations
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial

//âœ… equation-section :
//âœ…    [ initial ] equation { some-equation ";" }
pub EquationSection: fragment::EquationSection = {
    <initial:"initial"?>
    "equation"
    <equations:TerminatedList<Equation, ";">>
    => {
        fragment::EquationSection {
            initial: initial.is_some(),
            equations,
        }
    }
}
//âœ… algorithm-section :
//âœ…    [ initial ] algorithm { statement ";" }
pub AlgorithmSection: fragment::AlgorithmSection = {
    <initial:"initial"?>
    "algorithm"
    <statements:TerminatedList<Statement, ";">>
    => {
        fragment::AlgorithmSection {
            initial: initial.is_some(),
            statements,
        }
    }
}

//ğŸŸ¨ some-equation :
//âœ…    ( simple-expression "=" expression
//âœ…      | if-equation
//âœ…      | for-equation
//âœ…      | connect-equation
//ğŸŸ¥      | when-equation
//ğŸŸ¥      | component-reference function-call-args )
//ğŸŸ¥    description
pub Equation: node::Equation = {
    <eq: EquationSimple> => node::Equation::Simple(eq),
    <eq: EquationIf> => node::Equation::If(eq),
    <eq: EquationFor> => node::Equation::For(eq),
    <eq: EquationConnect> => node::Equation::Connect(eq),
}

pub EquationSimple: node::EquationSimple = {
    <left: @L> <lhs:ExpressionSimple> "=" <rhs:Expression> <description: Description> <right: @R>=> {
        let id = context.new_id();
        node::EquationSimple {
            node_data: part::NodeData::new(id, left, right),
            lhs,
            rhs,
            description,
        }
    }
}

//âœ… statement :
//âœ…    ( component-reference ( ":=" expression | function-call-args )
//ğŸŸ¥      | "(" output-expression-list ")" ":=" component-reference function-call-args
//âœ…      | break
//âœ…      | return
//âœ…      | if-statement
//âœ…      | for-statement
//âœ…      | while-statement
//ğŸŸ¥      | when-statement )
//âœ…    description

pub Statement: node::Statement = {
    <stmt: StatementAssignment> => node::Statement::Assignment(stmt),
    <stmt: StatementIf> => node::Statement::If(stmt),
    <stmt: StatementFor> => node::Statement::For(stmt),
    <stmt: StatementWhile> =>  node::Statement::While(stmt),
    <stmt: StatementBreak> =>  node::Statement::Break(stmt),
    <stmt: StatementReturn> =>  node::Statement::Return(stmt),
}

pub StatementAssignment: node::StatementAssignment = {
    <left: @L> <comp: ComponentReference> ":="
    <rhs:Expression> <description: Description> <right: @R> => {
        let id = context.new_id();
        node::StatementAssignment {
            node_data: part::NodeData::new(id, left, right),
            comp,
            rhs,
            description,
        }
    }
}

pub StatementBreak: node::StatementBreak = {
    <left: @L> "break" <description: Description> <right: @R> => {
        let id = context.new_id();
        node::StatementBreak {
            node_data: part::NodeData::new(id, left, right),
            description,
        }
    },
}

pub StatementReturn: node::StatementReturn = {
    <left: @L> "return" <description: Description> <right: @R> => {
        let id = context.new_id();
        node::StatementReturn {
            node_data: part::NodeData::new(id, left, right),
            description,
        }
    },
}


//âœ… if-equation :
//âœ…    if expression then
//âœ…      { some-equation ";" }
//âœ…    { elseif expression then
//âœ…      { some-equation ";" }
//âœ…    }
//âœ…    [ else
//âœ…      { some-equation ";" }
//âœ…    ]
//âœ…    end if

pub EquationIf: node::EquationIf = {
    <left: @L> "if" <if_cond:Expression> "then"
    <then_eqs:TerminatedList<Equation, ";">>
    <else_if_blocks: EquationElseIfBlock*>
    <else_eqs: EquationElseBlock?>
    "end" "if" <description: Description> <right: @R>=> {
        let id = context.new_id();
        let mut if_blocks = Vec::<node::EquationIfBlock>::new();
        if_blocks.push(
            node::EquationIfBlock {
                node_data: part::NodeData::new(context.new_id(), left, right),
                cond: if_cond,
                eqs: then_eqs,
            }
        );
        if_blocks.extend(else_if_blocks);
        node::EquationIf {
            node_data: part::NodeData::new(id, left, right),
            if_blocks,
            else_eqs: else_eqs.unwrap_or(Vec::new()),
            description,
        }
    }
}

pub EquationElseIfBlock: node::EquationIfBlock = {
    <left: @L> "elseif" <cond:Expression> "then"
    <eqs:TerminatedList<Equation, ";">> <right: @R> => {
        let id = context.new_id();
        node::EquationIfBlock {
            node_data: part::NodeData::new(id, left, right),
            cond, eqs
        }
    }
}

pub EquationElseBlock: Vec<node::Equation> = {
    "else" <eqs:TerminatedList<Equation, ";">> => {
        eqs
    }
}

//âœ… if-statement :
//âœ…    if expression then
//âœ…      { statement ";" }
//âœ…    { elseif expression then
//âœ…      { statement ";" }
//âœ…    }
//âœ…    [ else
//âœ…      { statement ";" }
//âœ…    ]
//âœ…    end if
pub StatementIf: node::StatementIf = {
    <left: @L> "if" <if_cond:Expression> "then"
    <then_stmts:TerminatedList<Statement, ";">>
    <else_if_blocks: StatementElseIfBlock*>
    <else_stmts: StatementElseBlock?>
    "end" "if" <description: Description> <right: @R> => {
        let id = context.new_id();
        let mut if_blocks = Vec::<node::StatementIfBlock>::new();
        if_blocks.push(
            node::StatementIfBlock {
                node_data: part::NodeData::new(context.new_id(), left, right),
                cond: if_cond,
                stmts: then_stmts,
            }
        );
        if_blocks.extend(else_if_blocks);

        node::StatementIf {
            node_data: part::NodeData::new(id, left, right),
            if_blocks,
            else_stmts: else_stmts.unwrap_or(Vec::new()),
            description,
        }
    }
}

pub StatementElseIfBlock: node::StatementIfBlock = {
    <left: @L> "elseif" <cond:Expression> "then"
    <stmts:TerminatedList<Statement, ";">> <right: @R> => {
        let id = context.new_id();
        node::StatementIfBlock {
            node_data: part::NodeData::new(id, left, right),
            cond, stmts
        }
    }
}

pub StatementElseBlock: Vec<node::Statement> = {
    "else" <stmts:TerminatedList<Statement, ";">> => {
        stmts
    }
}

//âœ… for-equation :
//âœ…    for for-indices loop
//âœ…      { some-equation ";" }
//âœ…    end for
pub EquationFor: node::EquationFor = {
    <left: @L> "for" <indices: ForIndices> "loop"
    <eqs: TerminatedList<Equation, ";">>
    "end" "for" <description: Description> <right: @R>
    => {
        let id = context.new_id();
        node::EquationFor {
            node_data: part::NodeData::new(id, left, right),
            indices,
            eqs,
            description,
        }
    }
}

//âœ… for-statement :
//âœ…    for for-indices loop
//âœ…      { statement ";" }
//âœ…    end for
pub StatementFor: node::StatementFor = {
    <left: @L> "for" <indices: ForIndices> "loop"
    <stmts: TerminatedList<Statement, ";">>
    "end" "for" <description: Description> <right: @R>
    => {
        let id = context.new_id();
        node::StatementFor {
            node_data: part::NodeData::new(id, left, right),
            indices,
            stmts,
            description,
        }
    }
}

//âœ… for-indices :
//âœ…    for-index { "," for-index }
ForIndices: Vec<node::ForIndex> = {
    <indices: SeparatedList<ForIndex, ",">> => indices
}

//âœ… for-index :
//âœ…    IDENT [ in expression ]
pub ForIndex: node::ForIndex = {
    <left: @L> <ident: IDENT> <in_expr:("in" <Expression>)?> <right: @R> => {
        let id = context.new_id();
        node::ForIndex {
            node_data: part::NodeData::new(id, left, right),
            ident,
            in_expr,
        }
    }
}

//âœ… while-statement :
//âœ…    while expression loop
//âœ…      { statement ";" }
//âœ…    end while
pub StatementWhile: node::StatementWhile = {
    <left: @L> "while" <cond: Expression> "loop"
    <stmts: TerminatedList<Statement, ";">>
    "end" "while" <right: @R>
    => {
        let id = context.new_id();
        node::StatementWhile {
            node_data: part::NodeData::new(id, left, right),
            cond,
            stmts,
            description: None,
        }
    }
}

//ğŸŸ¥ when-equation :
//ğŸŸ¥    when expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    { elsewhen expression then
//ğŸŸ¥      { some-equation ";" }
//ğŸŸ¥    }
//ğŸŸ¥    end when

//ğŸŸ¥ when-statement :
//ğŸŸ¥    when expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    { elsewhen expression then
//ğŸŸ¥      { statement ";" }
//ğŸŸ¥    }
//ğŸŸ¥    end when

//âœ… connect-equation :
//âœ…    connect "(" component-reference "," component-reference ")"
pub EquationConnect: node::EquationConnect = {
    <left: @L> "connect" "("
    <lhs: ComponentReference> ","
    <rhs: ComponentReference> ")"
    <description: Description> <right: @R> => {
        let id = context.new_id();
        node::EquationConnect {
            node_data: part::NodeData::new(id, left, right),
            lhs,
            rhs,
            description,
        }
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// A.2.7 Expressions
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// âœ…: Implemented,  ğŸŸ¥: Not-Implemented, ğŸŸ¨: Partial


//âœ… expression :
//âœ…     simple-expression
//âœ…    | if expression then expression { elseif expression then expression } else expression

//ğŸŸ¨  simple-expression :
//âœ…     logical-expression
//ğŸŸ¥     [ ":" logical-expression [ ":" logical-expression ] ]
pub Expression: node::Expression = {
    <expr: ExpressionSimple> =>  expr,
    <expr: ExpressionIf> => node::Expression::If(expr),
}

pub ExpressionIf: node::ExpressionIf = {
    <left: @L> "if" <if_cond:ExpressionSimple> "then"
    <then_expr:ExpressionSimple>
    <else_if_blocks: ExpressionElseIfBlock*>
    <else_expr: ExpressionElseBlock?> <right: @R>
     => {
        let id = context.new_id();
        let mut if_blocks = Vec::<node::ExpressionIfBlock>::new();
        if_blocks.push(
            node::ExpressionIfBlock {
                node_data: part::NodeData::new(context.new_id(), left, right),
                cond: if_cond,
                expr: then_expr,
            }
        );
        if_blocks.extend(else_if_blocks);

        node::ExpressionIf {
            node_data: part::NodeData::new(id, left, right),
            if_blocks,
            else_expr: Box::new(else_expr),
        }
    }
}


pub ExpressionElseIfBlock: node::ExpressionIfBlock = {
    <left: @L> "elseif" <cond:ExpressionSimple> "then" <expr:ExpressionSimple> <right: @R> => {
        let id = context.new_id();
        node::ExpressionIfBlock {
            node_data: part::NodeData::new(id, left, right),
            cond, expr
        }
    }
}

pub ExpressionElseBlock: node::Expression = {
    "else" <expr:ExpressionSimple> => {
        expr
    }
}

pub ParenthesisExpression = ExpressionSimple;

//âœ… relational-operator :
//âœ…    "<" | "<=" | ">" | ">=" | "==" | "<>"
RelationalOperator : part::BinaryOp = {
    "<" => part::BinaryOp::LessThan,
    "<=" => part::BinaryOp::LessThanOrEqual,
    ">" => part::BinaryOp::GreaterThan,
    ">=" => part::BinaryOp::GreaterThanOrEqual,
    "==" => part::BinaryOp::Equal,
    "<>" => part::BinaryOp::NotEqual,
}

//âœ… add-operator :
//âœ…    "+" | "-" | ".+" | ".-"
AddBinaryOperator : part::BinaryOp = {
    "+" => part::BinaryOp::Add,
    "-" => part::BinaryOp::Sub,
    ".+" => part::BinaryOp::ElemAdd,
    ".-" => part::BinaryOp::ElemSub,
}
AddUnaryOperator : part::UnaryOp = {
    "-" => part::UnaryOp::Negative,
}

FactorOperator : part::BinaryOp = {
    "^" => part::BinaryOp::Exp,
    ".^" => part::BinaryOp::ElemExp,
}

//âœ… mul-operator :
//âœ…    "*" | "/" | ".*" | "./"
MulOperator : part::BinaryOp = {
    "*" => part::BinaryOp::Mul,
    "/" => part::BinaryOp::Div,
    ".*" => part::BinaryOp::ElemMul,
    "./" => part::BinaryOp::ElemDiv,
}

FuncKeyword: String = {
    <"der"> => String::from("der"),
    // <"initial"> => String::from("initial"),
    // <"pure"> => String::from("pure"),
};

ExpressionSimple: node::Expression = {
//âœ… simple-expression :
//âœ…    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
    #[precedence(level="11")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> ":" <rhs:ExpressionSimple> <right: @R> => {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op: part::BinaryOp::Range,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… logical-expression :
//âœ…    logical-term { or logical-term }
    #[precedence(level="10")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> "or" <rhs:ExpressionSimple> <right: @R> => {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op: part::BinaryOp::Or,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… logical-term :
//âœ…    logical-factor { and logical-factor }
    #[precedence(level="9")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> "and" <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op: part::BinaryOp::Add,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… logical-factor :
//âœ…    [ not ] relation
    #[precedence(level="8")]
    <left: @L> "not" <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Unary(node::Unary {
            node_data: part::NodeData::new(id, left, right),
            op: part::UnaryOp::Not,
            rhs: Box::new(rhs),
        })
    },
//âœ… relation :
//âœ…    arithmetic-expression [ relational-operator arithmetic-expression ]
    #[precedence(level="7")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op:RelationalOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… arithmetic-expression :
//âœ…    [ add-operator ] term { add-operator term }
    #[precedence(level="6")] #[assoc(side="right")]
    <left: @L> <op:AddUnaryOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Unary(node::Unary {
            node_data: part::NodeData::new(id, left, right),
            op,
            rhs: Box::new(rhs),
        })
    },
    #[precedence(level="5")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op:AddBinaryOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… term :
//âœ…    factor { mul-operator factor }
    #[precedence(level="4")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op: MulOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… factor :
//âœ…    primary [ ( "^" | ".^" ) primary ]
    #[precedence(level="3")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op:FactorOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        node::Expression::Binary(node::Binary {
            node_data: part::NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//âœ… primary :
//âœ…    UNSIGNED-NUMBER
//ğŸŸ¥    | STRING
//âœ…    | false
//âœ…    | true
//âœ…    | ( component-reference
//âœ…        | der
//âœ…        | initial
//âœ…        | pure ) function-call-args
//âœ…    | component-reference
//ğŸŸ¥    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//ğŸŸ¥    | "[" expression-list { ";" expression-list } "]"
//ğŸŸ¥    | "{" array-arguments "}"
//ğŸŸ¥    | end
    #[precedence(level="0")]
    <left: @L> "(" <rhs:ParenthesisExpression> ")" <right: @R> => {
        let id = context.new_id();
        node::Expression::Unary(node::Unary {
            node_data: part::NodeData::new(id, left, right),
            op: part::UnaryOp::Paren,
            rhs: Box::new(rhs),
        })
    },
    <left: @L> "{" <args:SeparatedList<Expression, ",">> "}" <right: @R> => {
        let id = context.new_id();
        node::Expression::Array(node::Array {
            node_data: part::NodeData::new(id, left, right),
            args
        })
    },
    <left: @L> <val:"UNSIGNED-INTEGER"> <right: @R> => {
        let id = context.new_id();
        node::Expression::UnsignedInteger(node::UnsignedInteger {
            node_data: part::NodeData::new(id, left, right),
            val,
        })
    },
    <left: @L> <val:"UNSIGNED-REAL"> <right: @R> => {
        let id = context.new_id();
        node::Expression::UnsignedReal(node::UnsignedReal {
            node_data: part::NodeData::new(id, left, right),
            val,
        })
    },
    <left: @L> <val:"boolean"> <right: @R> => {
        let id = context.new_id();
        node::Expression::Boolean(node::Boolean {
            node_data: part::NodeData::new(id, left, right),
            val,
        })
    },
    <comp:ComponentReference> => {
        node::Expression::Ref(comp)
    },
    #[precedence(level="1")]
    <left: @L> <comp:ComponentReference> <args:FunctionCallArguments> <right: @R> => {
        let id = context.new_id();
        node::Expression::FunctionCall(node::FunctionCall {
            node_data: part::NodeData::new(id, left, right),
            comp,
            args,
        })
    },
    <left: @L> <func: FuncKeyword> <args:FunctionCallArguments> <right: @R> => {
        let id = context.new_id();
        node::Expression::FunctionCall(node::FunctionCall {
            node_data: part::NodeData::new(id, left, right),
            comp:  node::ComponentReference{
                node_data: part::NodeData::new(context.new_id(), left, right),
                local: false,
                parts: vec![node::RefPart{
                    node_data: part::NodeData::new(context.new_id(), left, right),
                    name: func,
                    array_subscripts: Vec::new(),
                }]
            },
            args,
        })
    },
}

//âœ… UNSIGNED-NUMBER :
//âœ…    UNSIGNED-INTEGER | UNSIGNED-REAL
// NOTE: flattened in primary

//âœ… type-specifier :
//âœ…    ["."] name
pub TypeSpecifier: node::TypeSpecifier = {
    <left: @L> <local: "."?> <name: Name> <right: @R> => {
        let id = context.new_id();
        node::TypeSpecifier{
            node_data: part::NodeData::new(id, left, right),
            local: local.is_some(),
            name,
        }
    },
}

//âœ… name :
//âœ…    IDENT { "." IDENT }
pub Name: part::Name = {
    <first:IDENT> <remaining: ("." <IDENT>)*> => {
        let mut v = vec![first];
        v.extend(remaining);
        part::Name {
            parts: v
        }
    }
}

//âœ… component-reference :
//âœ…    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
pub ComponentReference:  node::ComponentReference = {
    <left: @L> <local: "."?> <parts: SeparatedListMinOne<RefPart, ".">> <right: @R> => {
        let id = context.new_id();
         node::ComponentReference{
            node_data: part::NodeData::new(id, left, right),
            local: local.is_some(),
            parts,
        }
    },
}
pub RefPart: node::RefPart = {
    <left: @L> <name:IDENT> <array_subscripts:ArraySubscripts?> <right: @R> => {
        let id = context.new_id();
        node::RefPart {
            node_data: part::NodeData::new(id, left, right),
            name,
            array_subscripts: array_subscripts.unwrap_or(Vec::new()),
        }
    }
}

//ğŸŸ¥ result-reference :
//ğŸŸ¥    component-reference
//ğŸŸ¥    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"

//âœ… function-call-args :
//âœ…    "(" [ function-arguments ] ")"
pub FunctionCallArguments: Vec<node::Expression> = {
    <left: @L> "(" <args:SeparatedList<Expression, ",">> ")" <right: @R> => {
        args
    }
}

//ğŸŸ¥ function-arguments :
//ğŸŸ¥    expression [ "," function-arguments-non-first | for for-indices ]
//ğŸŸ¥    | function-partial-application [ "," function-arguments-non-first ]
//ğŸŸ¥    | named-arguments

//ğŸŸ¥ function-arguments-non-first :
//ğŸŸ¥    function-argument [ "," function-arguments-non-first ]
//ğŸŸ¥    | named-arguments

//ğŸŸ¥ array-arguments :
//ğŸŸ¥    expression [ "," array-arguments-non-first | for for-indices ]

//ğŸŸ¥ array-arguments-non-first :
//ğŸŸ¥    expression [ "," array-arguments-non-first ]

//ğŸŸ¥ named-arguments: named-argument [ "," named-arguments ]

//ğŸŸ¥ named-argument: IDENT "=" function-argument

//ğŸŸ¥ function-argument :
//ğŸŸ¥    function-partial-application | expression

//ğŸŸ¥ function-partial-application :
//ğŸŸ¥    function type-specifier "(" [ named-arguments ] ")"

//ğŸŸ¥ output-expression-list :
//ğŸŸ¥    [ expression ] { "," [ expression ] }

//ğŸŸ¥ expression-list :
//ğŸŸ¥    expression { "," expression }

//âœ… array-subscripts :
//âœ…    "[" subscript { "," subscript } "]"
pub ArraySubscripts: Vec<node::Subscript> = {
    "[" <subscripts: SeparatedList<Subscript, ",">> "]" => {
        subscripts
    }
}
//âœ… subscript :
//âœ…    ":" | expression
pub Subscript: node::Subscript = {
    <sub: SubscriptRange> => node::Subscript::Range(sub),
    <sub: Expression> => node::Subscript::Expression(sub),
}

pub SubscriptRange: node::SubscriptRange = {
    <left: @L> ":" <right: @R> => {
        let id = context.new_id();
        node::SubscriptRange {
            node_data: part::NodeData::new(id, left, right),
        }
    },
}

//âœ… description :
//âœ…    description-string [ annotation-clause ]
pub Description: Option<node::Description> = {
    <left: @L> <description_string: DescriptionString>
    <annotation: AnnotationClause?> <right: @R>
    => {
        if left == right {
            None
        } else {
            let id = context.new_id();
            Some(node::Description {
                node_data: part::NodeData::new(id, left, right),
                strings: description_string.parts,
                annotation: annotation.unwrap_or(Vec::new()),
            })
        }
    },
}

//âœ… description-string :
//âœ…    [ STRING { "+" STRING } ]
pub DescriptionString: part::DescriptionString = {
    <s:DescriptionStringPart?> => {
        part::DescriptionString {
            parts: s.unwrap_or(Vec::new())
        }
    }
}
// Note: LALRPOP doesn't like empty expressions here, so
// adding level of indirection with DescriptionStringPart
DescriptionStringPart: Vec<String> = {
    <first:"STRING"> <remaining: ("+" <"STRING">)*> => {
        let mut v = vec![first];
        v.extend(remaining);
        v
    }
}

//âœ… annotation-clause :
//âœ…    annotation class-modification
pub AnnotationClause: Vec<node::Argument> = {
    "annotation" <modification:ModificationClass> => {
        modification
    },
}
