// Based on Modelica 3.7-dev Specification
use crate::s0_lexer::tokens::{Token, LexicalError};
use crate::s1_parser::ast;
use crate::s1_parser::ast::NodeData;
use crate::s1_parser::ast::ParserContext;

grammar(context: &mut ParserContext);

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// LALRPOP macros
SeparatedList<T, Str>: Vec<T> = {
    <mut v:(<T> Str)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SeparatedListMinOne<T, Str>: Vec<T> = {
    <e:T> <v:(Str <T>)*>  => {
        let mut res = vec![e];
        res.extend(v);
        res
    }
};

TerminatedList<T, Str>: Vec<T> = {
    <v:(<T> Str)*> => v

};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2.3.3 Modelica Keywords

extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        // keywords
        "algorithm" => Token::KeywordAlgorithm,
        "and" => Token::KeywordAnd,
        "annotation" => Token::KeywordAnnotation,
        "block" => Token::KeywordBlock,
        "break" => Token::KeywordBreak,
        "class" => Token::KeywordClass,
        "connect" => Token::KeywordConnect,
        "connector" => Token::KeywordConnector,
        "constant" => Token::KeywordConstant,
        "constrainedby" => Token::KeywordConstrainedby,
        "der" => Token::KeywordDer,
        "discrete" => Token::KeywordDiscrete,
        "each" => Token::KeywordEach,
        "else" => Token::KeywordElse,
        "elseif" => Token::KeywordElseif,
        "elsewhen" => Token::KeywordElsewhen,
        "encapsulated" => Token::KeywordEncapsulated,
        "end" => Token::KeywordEnd,
        "enumeration" => Token::KeywordEnumeration,
        "equation" => Token::KeywordEquation,
        "expandable" => Token::KeywordExpandable,
        "extends" => Token::KeywordExtends,
        "external" => Token::KeywordExternal,
        "final" => Token::KeywordFinal,
        "flow" => Token::KeywordFlow,
        "for" => Token::KeywordFor,
        "function" => Token::KeywordFunction,
        "if" => Token::KeywordIf,
        "import" => Token::KeywordImport,
        "impure" => Token::KeywordImpure,
        "in" => Token::KeywordIn,
        "initial" => Token::KeywordInitial,
        "inner" => Token::KeywordInner,
        "input" => Token::KeywordInput,
        "loop" => Token::KeywordLoop,
        "model" => Token::KeywordModel,
        "not" => Token::KeywordNot,
        "operator" => Token::KeywordOperator,
        "or" => Token::KeywordOr,
        "outer" => Token::KeywordOuter,
        "output" => Token::KeywordOutput,
        "package" => Token::KeywordPackage,
        "parameter" => Token::KeywordParameter,
        "partial" => Token::KeywordPartial,
        "protected" => Token::KeywordProtected,
        "public" => Token::KeywordPublic,
        "pure" => Token::KeywordPure,
        "record" => Token::KeywordRecord,
        "redeclare" => Token::KeywordRedeclare,
        "replaceable" => Token::KeywordReplaceable,
        "return" => Token::KeywordReturn,
        "stream" => Token::KeywordStream,
        "then" => Token::KeywordThen,
        "type" => Token::KeywordType,
        "when" => Token::KeywordWhen,
        "while" => Token::KeywordWhile,
        "within" => Token::KeywordWithin,

        // other lexical tokens
        "IDENT" => Token::Identifier(<String>),
        "STRING" => Token::String(<String>),
        "UNSIGNED-INTEGER" => Token::UnsignedInteger(<String>),
        "UNSIGNED-REAL" => Token::UnsignedReal(<String>),
        "boolean" => Token::Boolean(<bool>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ":=" => Token::Assign,
        "=" => Token::Equal,
        ";" => Token::Semicolon,
        "." => Token::Period,
        ":" => Token::Colon,
        "," => Token::Comma,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
        "^" => Token::OperatorExp,

        ".+" => Token::OperatorElemAdd,
        ".-" => Token::OperatorElemSub,
        ".*" => Token::OperatorElemMul,
        "./" => Token::OperatorElemDiv,
        ".^" => Token::OperatorElemExp,

        "<" => Token::OperatorLessThan,
        "<=" => Token::OperatorLessThanOrEqual,
        ">" => Token::OperatorGreaterThan,
        ">=" => Token::OperatorGreaterThanOrEqual,
        "==" => Token::OperatorEqual,
        "<>" => Token::OperatorNotEqual,
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.1 Stored Definition – Within
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial

//✅ stored-definition :
//✅    [ within [ name ] ";" ]
//✅    { [ final ] class-definition ";" }
pub StoredDefinition: ast::StoredDefinition = {
    <left: @L>
    <within: ("within" <Name> ";")?>
    <classes:TerminatedList<ClassDefinitionWithFinal, ";">>
    <right: @R> => {
        let id = context.new_id();
        let node_data = NodeData::new(id, left, right);
        ast::StoredDefinition {
            node_data,
            classes: classes.into_iter()
                .map(|class| (class.name.clone(), class)).collect(),
            within,
            rumoca_parser_version: "".to_string(),
            rumoca_parser_git: "".to_string(),
            model_md5: "".to_string(),
        }
    }
}

ClassDefinitionWithFinal: ast::ClassDefinition = {
    <is_final: "final"?> <mut class: ClassDefinition> => {
        class.flags.is_final = is_final.is_some();
        class
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.2 Class Definition
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial

//✅ class-definition :
//✅    [ encapsulated ] class-prefixes class-specifier
pub ClassDefinition: ast::ClassDefinition = {
    <left: @L> <encapsulated: "encapsulated"?>
    <prefixes: ClassPrefixes>
    <specifier: ClassSpecifier> <right: @R> => {
        let id = context.new_id();
        let (name, modification, description, composition) = match specifier {
            ast::ClassSpecifier::Long(spec) => (spec.name, Vec::new(), spec.description, spec.composition),
            ast::ClassSpecifier::Extends(spec) => (spec.name, spec.modification, spec.description, spec.composition),
            ast::ClassSpecifier::Empty => panic!("Empty ClassSpecifier"),
        };

        let mut def = ast::ClassDefinition {
            node_data: NodeData::new(id, left, right),
            name,
            class_type: prefixes.class_type,
            flags: ast::ClassFlags {
                encapsulated: encapsulated.is_some(),
                partial: prefixes.is_partial,
                ..Default::default()
            },
            modification,
            description,
            ..Default::default()
        };

        for part in composition {
            match part {
                ast::CompositionPart::ElementList(list) => {
                    for element in list.elements {
                    }
                },
                ast::CompositionPart::AlgorithmSection(sec) => {
                    if sec.initial {
                        def.initial_algorithms.push(sec.statements);
                    } else {
                        def.algorithms.push(sec.statements);
                    }
                }
                ast::CompositionPart::EquationSection(sec) => {
                    if sec.initial {
                        def.initial_equations.extend(sec.equations);
                    } else {
                        def.equations.extend(sec.equations);
                    }
                }
                _ => {}
            }
        }

        def
    }
}
//✅ class-prefixes :
//✅    [ partial ]
//✅    ( class
//✅      | model
//✅      | [ operator ] record
//✅      | block
//✅      | [ expandable ] connector
//✅      | type
//✅      | package
//✅      | [ pure | impure ] [ operator ] function
//✅      | operator
//✅    )
ClassPrefixes: ast::ClassPrefixes = {
    <left: @L> <partial: "partial"?> <class_type: ClassType> <right: @R> => {
        ast::ClassPrefixes {
            is_partial: partial.is_some(),
            class_type,
        }
    }
}

pub ClassType: ast::ClassType = {
    "class" => ast::ClassType::Class,
    "model" => ast::ClassType::Model,
    "record" => ast::ClassType::Record,
    "operator" "record" => ast::ClassType::OperatorRecord,
    "block" => ast::ClassType::Block,
    "expandable" "connector" => ast::ClassType::ExpandableConnector,
    "connector" => ast::ClassType::Connector,
    "type" => ast::ClassType::Type,
    "package" => ast::ClassType::Package,
    "pure" "function" => ast::ClassType::PureFunction,
    "impure" "function" => ast::ClassType::ImpureFunction,
    "operator" "function" => ast::ClassType::OperatorFunction,
    "function" => ast::ClassType::Function,
    "operator" => ast::ClassType::Operator,
}

//✅ class-specifier :
//✅    long-class-specifier
//🟥     | short-class-specifier
//🟥     | der-class-specifier
pub ClassSpecifier: ast::ClassSpecifier = {
    <spec: ClassSpecifierLong> => ast::ClassSpecifier::Long(spec),
    <spec: ClassSpecifierExtends> => ast::ClassSpecifier::Extends(spec),
}

pub IDENT: String = {
    <ident: "IDENT"> => ident,
}

//✅ long-class-specifier :
//✅    IDENT description-string composition end IDENT
//✅    | extends IDENT [ class-modification ] description-string composition end IDENT
pub ClassSpecifierLong: ast::ClassSpecifierLong = {
    <left: @L> <name: IDENT>
    <description: DescriptionString>
    <composition: Composition>
    "end"
    <name_end: IDENT> <right: @R> => {
        let id = context.new_id();
        ast::ClassSpecifierLong {
            node_data: NodeData::new(id, left, right),
            name,
            description,
            composition,
            name_end,
        }
    }
}

pub ClassSpecifierExtends: ast::ClassSpecifierExtends = {
    <left: @L> "extends" <name: IDENT>
    <modification: ModificationClass?>
    <description: DescriptionString>
    <composition: Composition>
    "end" <name_end: IDENT> <right: @R> => {
        let id = context.new_id();
        ast::ClassSpecifierExtends {
            node_data: NodeData::new(id, left, right),
            name,
            modification: modification.unwrap_or(Vec::new()),
            description,
            composition,
            name_end,
        }
    }
}


//🟥 short-class-specifier :
//🟥    IDENT "=" base-prefix type-specifier [ array-subscripts ] [ class-modification ] description
//🟥    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description

//🟥 der-class-specifier :
//🟥    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description

//🟥 base-prefix :
//🟥    [ input | output ]

//🟥 enum-list :
//🟥    enumeration-literal { "," enumeration-literal }

//🟥 enumeration-literal :
//🟥    IDENT description

//✅ composition :
//✅    element-list
//✅    { public element-list
//✅      | protected element-list
//✅      | equation-section
//✅      | algorithm-section
//✅    }
//🟥    [ external [ language-specification ]
//🟥      [ external-function-call ] [ annotation-clause ] ";"
//🟥    ]
//🟥    [ annotation-clause ";" ]
pub Composition: Vec<ast::CompositionPart> = {
    <left: @L> <first:ElementList>
    <remaining: CompositionPart*> <right: @R>
    => {
        let id = context.new_id();
        let mut v = Vec::new();
        v.push(ast::CompositionPart::ElementList(ast::ElementList {
            node_data: NodeData::new(id, left, right),
            visibility: ast::Visibility::Public,
            elements: first,
        }));
        v.extend(remaining);
        v
    }
}

pub CompositionPart: ast::CompositionPart = {
    <comp: AlgorithmSection> => ast::CompositionPart::AlgorithmSection(comp),
    <comp: ElementListWithVisibility> => ast::CompositionPart::ElementList(comp),
    <comp: EquationSection> => ast::CompositionPart::EquationSection(comp),
}

pub ElementListWithVisibility: ast::ElementList = {
    <left: @L> <visibility:Visibility> <elements: ElementList> <right: @R> => {
        let id = context.new_id();
        ast::ElementList {
            node_data: NodeData::new(id, left, right),
            visibility,
            elements,
        }
    }
}

pub Visibility: ast::Visibility = {
    "public" => ast::Visibility::Public,
    "protected" => ast::Visibility::Protected,
}

//✅ language-specification :
//✅    STRING
pub LanguageSpecification: String = {
    <string:"STRING"> => string 
}
//🟥 external-function-call :
//🟥    [ component-reference "=" ] IDENT "(" [ expression-list ] ")"

//✅ element-list :
//✅    { element ";" }
pub ElementList: Vec<ast::Element> = {
    <elements:TerminatedList<Element, ";">> => elements
}

//✅ element :
//✅    import-clause
//✅    | extends-clause
//✅    | [ redeclare ] [ final ] [ inner ] [ outer ] (
//✅        class-definition
//✅        | component-clause
//✅        | replaceable (
//✅          class-definition
//✅          | component-clause)
//🟥        [ constraining-clause description ])
pub ElementFlags : ast::ElementFlags = {
    <redeclare:"redeclare"?>
    <is_final:"final"?>
    <inner:"inner"?>
    <outer:"outer"?>
    <replaceable:"replaceable"?> => {
        ast::ElementFlags {
            redeclare: redeclare.is_some(),
            is_final: is_final.is_some(),
            inner: inner.is_some(),
            outer: outer.is_some(),
            replaceable: replaceable.is_some(),
        }
    }
}

pub Element : ast::Element = {
    <elem: ComponentClause> => ast::Element::ComponentClause(elem),
    <elem: ClassDefinition> => ast::Element::ClassDefinition(elem),
    <elem: ExtendsClause> => ast::Element::ExtendsClause(elem),
}

pub ElementComponentClause : ast::ComponentClause = {
    <left: @L> <flags: ElementFlags> <clause: ComponentClause> <right: @R> => {
        let mut res = clause;
        res.flags = flags;
        res.node_data.span = (left, right);
        res
    },
}

pub ElementClassDefinition : ast::ClassDefinition = {
    <left: @L> <flags: ElementFlags> <def: ClassDefinition> <right: @R>  => {
        let mut res = def;
        res.flags.redeclare = flags.redeclare;
        res.flags.is_final = flags.is_final;
        res.flags.inner = flags.inner;
        res.flags.outer = flags.outer;
        res.flags.replaceable = flags.replaceable;
        res.node_data.span = (left, right);
        res
    },
}

//✅ import-clause :
//✅    import
//✅    ( IDENT "=" name
//🟥      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ])
//✅    description

pub ImportClause : ast::ImportClause = {
    // qualified import
    <left: @L> "import" <name: Name> <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::ImportClause {
            node_data: NodeData::new(id, left, right),
            alias: "".to_string(),
            name,
            description,
        }
    },
    // unqualified import
    // "import" <name: Name> ".*" <description: Description> => {
    //     ast::Element::ImportClause {
    //         alias: None,
    //         name,
    //     }
    // },
    // renaming qualified import
    // "import" <alias:IDENT> "=" <name: Name> <description: Description> => {
    //     ast::Element::ImportClause {
    //         alias: None,
    //         name,
    //     }
    // },
    // multiple definition import
    // "import" <name:Name> "." "{" SeparatedListMinOne<IDENT, ","> "}"=> {
    //     ast::Element::ImportClause {
    //         alias: None,
    //         name,
    //     }
    // }
}

//✅ import-list :
//✅    IDENT { "," IDENT }
// Note: flattened into import-clause


// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.3 Extends
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial

//✅ extends-clause :
//✅    extends type-specifier
//🟥    [ class-or-inheritance-modification ]
//🟥    [ annotation-clause ]
pub ExtendsClause: ast::ExtendsClause = {
    "extends"
    <left: @L> <type_specifier: TypeSpecifier> <right: @R> => {
        let id = context.new_id();
        ast::ExtendsClause {
            node_data: NodeData::new(id, left, right),
            type_specifier,
        }
    }
}

//🟥 constraining-clause :
//🟥    constrainedby type-specifier [ class-modification ]

//🟥 class-or-inheritance-modification :
//🟥    "(" [ argument-or-inheritance-modification-list ] ")"

//🟥 argument-or-inheritance-modification-list :
//🟥     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }

//🟥 inheritance-modification :
//🟥     break ( connect-equation | IDENT )

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.4 Component Clause
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial

//✅ component-clause :
//✅    type-prefix type-specifier [ array-subscripts ] component-list
pub ComponentClause: ast::ComponentClause = {
    <left: @L> <type_prefix: TypePrefix>
    <type_specifier: TypeSpecifier>
    <array_subscripts: ArraySubscripts?>
    <components: ComponentList> <right: @R> => {
        let id = context.new_id();
        ast::ComponentClause {
            node_data: NodeData::new(id, left, right),
            type_specifier,
            flags: ast::ElementFlags::default(),
            connection: type_prefix.connection,
            variability: type_prefix.variability,
            causality: type_prefix.causality, 
            array_subscripts: array_subscripts.unwrap_or(Vec::new()),
            components,
        }
    }
}

//✅ type-prefix :
//✅    [ flow | stream ]
//✅    [ discrete | parameter | constant ]
//✅    [ input | output ]
pub TypePrefix: ast::TypePrefix = {
    <left: @L> <connection: Connection?>
    <variability: Variability?>
    <causality: Causality?> <right: @R> => {
        let id = context.new_id();
        ast::TypePrefix {
            connection: connection.unwrap_or(ast::Connection::Empty),
            variability: variability.unwrap_or(ast::Variability::Empty),
            causality: causality.unwrap_or(ast::Causality::Empty),
        }
    }
}
pub Connection: ast::Connection = {
    "flow" => ast::Connection::Flow,
    "stream" => ast::Connection::Stream,
}
pub Variability: ast::Variability = {
    "discrete" => ast::Variability::Discrete,
    "parameter" => ast::Variability::Parameter,
    "constant" => ast::Variability::Constant,
}
pub Causality: ast::Causality = {
    "input" => ast::Causality::Input,
    "output" => ast::Causality::Output,
}
//✅ component-list :
//✅    component-declaration { "," component-declaration }
pub ComponentList: Vec<ast::ComponentDeclaration> = {
    <components: SeparatedList<ComponentDeclaration, ",">> => {
        components
    }
}
//✅ component-declaration :
//✅    declaration [ condition-attribute ] description
pub ComponentDeclaration: ast::ComponentDeclaration = {
    <left: @L> <declaration: Declaration>
    <condition_attribute: ConditionAttribute?>
    <description: Description> <right: @R>
    => {
        let id = context.new_id();
        ast::ComponentDeclaration{
            node_data: NodeData::new(id, left, right),
            name: declaration.name,
            array_subscripts: declaration.array_subscripts,
            modification: declaration.modification,
            condition_attribute,
            description,
        }
    }
}
//✅ condition-attribute :
//✅    if expression
pub ConditionAttribute: ast::Expression = {
    "if" <cond: Expression> => cond
}
//✅ declaration :
//✅    IDENT [ array-subscripts ] [ modification ]
pub Declaration: ast::Declaration = {
    <left: @L> <name: IDENT>
    <array_subscripts:ArraySubscripts?>
    <modification:Modification?> <right: @R> => {
        let id = context.new_id();
        ast::Declaration {
            node_data: NodeData::new(id, left, right),
            name,
            array_subscripts: array_subscripts.unwrap_or(Vec::new()),
            modification,
        }
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.5 Modification
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial

//✅ modification :
//✅    class-modification [ "=" modification-expression ]
//✅    | "=" modification-expression
pub Modification: ast::Modification = {
    <left: @L> <args: ModificationClass> <expr: ("=" <ModExpr>)?> <right: @R> => {
        let id = context.new_id();
        ast::Modification::Class(ast::ModificationClass {
            node_data: NodeData::new(id, left, right),
            args,
            expr,
        })
    },
    "=" <expr: ModExpr> => {
        ast::Modification::Expression(expr)
    },
}

//✅ modification-expression :
//✅    expression
//✅    | break
pub ModExpr: ast::ModExpr = {
    <expr: Expression> => {
        ast::ModExpr::Expression(expr)
    },
    <left: @L> "break" <right: @R>=> {
        let id = context.new_id();
        ast::ModExpr::Break(ast::ModExprBreak {
            node_data: NodeData::new(id, left, right),
        })
    }
}

//✅ class-modification :
//✅    "(" [ argument-list ] ")"
pub ModificationClass: Vec<ast::Argument> = {
    "(" <args: SeparatedList<Argument, ",">> ")" => args
}

//✅ argument-list :
//✅    argument { "," argument }
// NOTE: flattend into class-modification above

//🟨 argument :
//🟨    element-modification-or-replaceable
//🟥    | element-redeclaration
pub Argument: ast::Argument = {
    <left: @L> <each: "each"?> <is_final: "final"?> <name: Name>
    <modification: Modification?> <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::Argument::Modification(ast::ArgumentModification {
            node_data: NodeData::new(id, left, right),
            name,
            modification,
            description,
            each: each.is_some(),
            is_final: is_final.is_some(),
        })
    },
}

//🟥 element-modification-or-replaceable :
//🟥    [ each ] [ final ] ( element-modification | element-replaceable )

//🟨 element-modification :
//🟨    name [ modification ] description-string

//🟥 element-redeclaration :
//🟥    redeclare [ each ] [ final ]
//🟥    ( short-class-definition | component-clause1 | element-replaceable )

//🟥 element-replaceable :
//🟥    replaceable ( short-class-definition | component-clause1 )
//🟥    [ constraining-clause ]

//✅ component-clause1 :
//✅    type-prefix type-specifier component-declaration1
pub ComponentClause1: ast::ComponentClause = {
    <left: @L> <type_prefix: TypePrefix>
    <type_specifier: TypeSpecifier>
    <component_declaration1: ComponentDeclaration1> <right: @R> => {
        let id = context.new_id();
        ast::ComponentClause {
            node_data: NodeData::new(id, left, right),
            type_specifier,
            flags: ast::ElementFlags::default(),
            connection: type_prefix.connection,
            variability: type_prefix.variability,
            causality: type_prefix.causality, 
            array_subscripts: Vec::new(),
            components: vec![component_declaration1],
        }
    }
}

//✅ component-declaration1 :
//✅    declaration description
pub ComponentDeclaration1: ast::ComponentDeclaration = {
    <left: @L> <declaration: Declaration>
    <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::ComponentDeclaration {
            node_data: NodeData::new(id, left, right),
            name: declaration.name,
            array_subscripts: declaration.array_subscripts,
            modification: declaration.modification,
            condition_attribute: None,
            description,
        }
    }
}

//🟥 short-class-definition :
//🟥    class-prefixes short-class-specifier

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.6 Equations
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial

//✅ equation-section :
//✅    [ initial ] equation { some-equation ";" }
pub EquationSection: ast::EquationSection = {
    <left: @L>
    <initial:"initial"?>
    "equation"
    <equations:TerminatedList<Equation, ";">>
    <right: @R>
    => {
        let id = context.new_id();
        ast::EquationSection {
            node_data: NodeData::new(id, left, right),
            initial: initial.is_some(),
            equations,
        }
    }
}
//✅ algorithm-section :
//✅    [ initial ] algorithm { statement ";" }
pub AlgorithmSection: ast::AlgorithmSection = {
    <left: @L> <initial:"initial"?>
    "algorithm"
    <statements:TerminatedList<Statement, ";">> <right: @R>
    => {
        let id = context.new_id();
        ast::AlgorithmSection {
            node_data: NodeData::new(id, left, right),
            initial: initial.is_some(),
            statements,
        }
    }
}

//🟨 some-equation :
//✅    ( simple-expression "=" expression
//✅      | if-equation
//✅      | for-equation
//✅      | connect-equation
//🟥      | when-equation
//🟥      | component-reference function-call-args )
//🟥    description
pub Equation: ast::Equation = {
    <eq: EquationSimple> => ast::Equation::Simple(eq),
    <eq: EquationIf> => ast::Equation::If(eq),
    <eq: EquationFor> => ast::Equation::For(eq),
    <eq: EquationConnect> => ast::Equation::Connect(eq),
}

pub EquationSimple: ast::EquationSimple = {
    <left: @L> <lhs:ExpressionSimple> "=" <rhs:Expression> <description: Description> <right: @R>=> {
        let id = context.new_id();
        ast::EquationSimple {
            node_data: NodeData::new(id, left, right),
            lhs,
            rhs,
            description,
        }
    }
}

//✅ statement :
//✅    ( component-reference ( ":=" expression | function-call-args )
//🟥      | "(" output-expression-list ")" ":=" component-reference function-call-args
//✅      | break
//✅      | return
//✅      | if-statement
//✅      | for-statement
//✅      | while-statement
//🟥      | when-statement )
//✅    description

pub Statement: ast::Statement = {
    <stmt: StatementAssignment> => ast::Statement::Assignment(stmt),
    <stmt: StatementIf> => ast::Statement::If(stmt),
    <stmt: StatementFor> => ast::Statement::For(stmt),
    <stmt: StatementWhile> =>  ast::Statement::While(stmt),
    <stmt: StatementBreak> =>  ast::Statement::Break(stmt),
    <stmt: StatementReturn> =>  ast::Statement::Return(stmt),
}

pub StatementAssignment: ast::StatementAssignment = {
    <left: @L> <comp: ComponentReference> ":="
    <rhs:Expression> <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::StatementAssignment {
            node_data: NodeData::new(id, left, right),
            comp,
            rhs,
            description,
        }
    }
}

pub StatementBreak: ast::StatementBreak = {
    <left: @L> "break" <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::StatementBreak {
            node_data: NodeData::new(id, left, right),
            description,
        }
    },
}

pub StatementReturn: ast::StatementReturn = {
    <left: @L> "return" <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::StatementReturn {
            node_data: NodeData::new(id, left, right),
            description,
        }
    },
}


//✅ if-equation :
//✅    if expression then
//✅      { some-equation ";" }
//✅    { elseif expression then
//✅      { some-equation ";" }
//✅    }
//✅    [ else
//✅      { some-equation ";" }
//✅    ]
//✅    end if

pub EquationIf: ast::EquationIf = {
    <left: @L> "if" <if_cond:Expression> "then"
    <then_eqs:TerminatedList<Equation, ";">>
    <else_if_blocks: EquationElseIfBlock*>
    <else_eqs: EquationElseBlock?>
    "end" "if" <description: Description> <right: @R>=> {
        let id = context.new_id();
        let mut if_blocks = Vec::<ast::EquationIfBlock>::new();
        if_blocks.push(
            ast::EquationIfBlock {
                node_data: NodeData::new(context.new_id(), left, right),
                cond: if_cond,
                eqs: then_eqs,
            }
        );
        if_blocks.extend(else_if_blocks);
        ast::EquationIf {
            node_data: NodeData::new(id, left, right),
            if_blocks,
            else_eqs: else_eqs.unwrap_or(Vec::new()),
            description,
        }
    }
}

pub EquationElseIfBlock: ast::EquationIfBlock = {
    <left: @L> "elseif" <cond:Expression> "then"
    <eqs:TerminatedList<Equation, ";">> <right: @R> => {
        let id = context.new_id();
        ast::EquationIfBlock {
            node_data: NodeData::new(id, left, right),
            cond, eqs
        }
    }
}

pub EquationElseBlock: Vec<ast::Equation> = {
    "else" <eqs:TerminatedList<Equation, ";">> => {
        eqs
    }
}

//✅ if-statement :
//✅    if expression then
//✅      { statement ";" }
//✅    { elseif expression then
//✅      { statement ";" }
//✅    }
//✅    [ else
//✅      { statement ";" }
//✅    ]
//✅    end if
pub StatementIf: ast::StatementIf = {
    <left: @L> "if" <if_cond:Expression> "then"
    <then_stmts:TerminatedList<Statement, ";">>
    <else_if_blocks: StatementElseIfBlock*>
    <else_stmts: StatementElseBlock?>
    "end" "if" <description: Description> <right: @R> => {
        let id = context.new_id();
        let mut if_blocks = Vec::<ast::StatementIfBlock>::new();
        if_blocks.push(
            ast::StatementIfBlock {
                node_data: NodeData::new(context.new_id(), left, right),
                cond: if_cond,
                stmts: then_stmts,
            }
        );
        if_blocks.extend(else_if_blocks);

        ast::StatementIf {
            node_data: NodeData::new(id, left, right),
            if_blocks,
            else_stmts: else_stmts.unwrap_or(Vec::new()),
            description,
        }
    }
}

pub StatementElseIfBlock: ast::StatementIfBlock = {
    <left: @L> "elseif" <cond:Expression> "then"
    <stmts:TerminatedList<Statement, ";">> <right: @R> => {
        let id = context.new_id();
        ast::StatementIfBlock {
            node_data: NodeData::new(id, left, right),
            cond, stmts
        }
    }
}

pub StatementElseBlock: Vec<ast::Statement> = {
    "else" <stmts:TerminatedList<Statement, ";">> => {
        stmts
    }
}

//✅ for-equation :
//✅    for for-indices loop
//✅      { some-equation ";" }
//✅    end for
pub EquationFor: ast::EquationFor = {
    <left: @L> "for" <indices: ForIndices> "loop"
    <eqs: TerminatedList<Equation, ";">>
    "end" "for" <description: Description> <right: @R>
    => {
        let id = context.new_id();
        ast::EquationFor {
            node_data: NodeData::new(id, left, right),
            indices,
            eqs,
            description,
        }
    }
}

//✅ for-statement :
//✅    for for-indices loop
//✅      { statement ";" }
//✅    end for
pub StatementFor: ast::StatementFor = {
    <left: @L> "for" <indices: ForIndices> "loop"
    <stmts: TerminatedList<Statement, ";">>
    "end" "for" <description: Description> <right: @R>
    => {
        let id = context.new_id();
        ast::StatementFor {
            node_data: NodeData::new(id, left, right),
            indices,
            stmts,
            description,
        }
    }
}

//✅ for-indices :
//✅    for-index { "," for-index }
ForIndices: Vec<ast::ForIndex> = {
    <indices: SeparatedList<ForIndex, ",">> => indices
}

//✅ for-index :
//✅    IDENT [ in expression ]
pub ForIndex: ast::ForIndex = {
    <left: @L> <ident: IDENT> <in_expr:("in" <Expression>)?> <right: @R> => {
        let id = context.new_id();
        ast::ForIndex {
            node_data: NodeData::new(id, left, right),
            ident,
            in_expr,
        }
    }
}

//✅ while-statement :
//✅    while expression loop
//✅      { statement ";" }
//✅    end while
pub StatementWhile: ast::StatementWhile = {
    <left: @L> "while" <cond: Expression> "loop"
    <stmts: TerminatedList<Statement, ";">>
    "end" "while" <right: @R>
    => {
        let id = context.new_id();
        ast::StatementWhile {
            node_data: NodeData::new(id, left, right),
            cond,
            stmts,
            description: None,
        }
    }
}

//🟥 when-equation :
//🟥    when expression then
//🟥      { some-equation ";" }
//🟥    { elsewhen expression then
//🟥      { some-equation ";" }
//🟥    }
//🟥    end when

//🟥 when-statement :
//🟥    when expression then
//🟥      { statement ";" }
//🟥    { elsewhen expression then
//🟥      { statement ";" }
//🟥    }
//🟥    end when

//✅ connect-equation :
//✅    connect "(" component-reference "," component-reference ")"
pub EquationConnect: ast::EquationConnect = {
    <left: @L> "connect" "("
    <lhs: ComponentReference> ","
    <rhs: ComponentReference> ")"
    <description: Description> <right: @R> => {
        let id = context.new_id();
        ast::EquationConnect {
            node_data: NodeData::new(id, left, right),
            lhs,
            rhs,
            description,
        }
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// A.2.7 Expressions
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ✅: Implemented,  🟥: Not-Implemented, 🟨: Partial


//✅ expression :
//✅     simple-expression
//✅    | if expression then expression { elseif expression then expression } else expression

//🟨  simple-expression :
//✅     logical-expression
//🟥     [ ":" logical-expression [ ":" logical-expression ] ]
pub Expression: ast::Expression = {
    <expr: ExpressionSimple> =>  expr,
    <expr: ExpressionIf> => ast::Expression::If(expr),
}

pub ExpressionIf: ast::ExpressionIf = {
    <left: @L> "if" <if_cond:ExpressionSimple> "then"
    <then_expr:ExpressionSimple>
    <else_if_blocks: ExpressionElseIfBlock*>
    <else_expr: ExpressionElseBlock?> <right: @R>
     => {
        let id = context.new_id();
        let mut if_blocks = Vec::<ast::ExpressionIfBlock>::new();
        if_blocks.push(
            ast::ExpressionIfBlock {
                node_data: NodeData::new(context.new_id(), left, right),
                cond: if_cond,
                expr: then_expr,
            }
        );
        if_blocks.extend(else_if_blocks);

        ast::ExpressionIf {
            node_data: NodeData::new(id, left, right),
            if_blocks,
            else_expr: Box::new(else_expr),
        }
    }
}


pub ExpressionElseIfBlock: ast::ExpressionIfBlock = {
    <left: @L> "elseif" <cond:ExpressionSimple> "then" <expr:ExpressionSimple> <right: @R> => {
        let id = context.new_id();
        ast::ExpressionIfBlock {
            node_data: NodeData::new(id, left, right),
            cond, expr
        }
    }
}

pub ExpressionElseBlock: ast::Expression = {
    "else" <expr:ExpressionSimple> => {
        expr
    }
}

pub ParenthesisExpression = ExpressionSimple;

//✅ relational-operator :
//✅    "<" | "<=" | ">" | ">=" | "==" | "<>"
RelationalOperator : ast::BinaryOp = {
    "<" => ast::BinaryOp::LessThan,
    "<=" => ast::BinaryOp::LessThanOrEqual,
    ">" => ast::BinaryOp::GreaterThan,
    ">=" => ast::BinaryOp::GreaterThanOrEqual,
    "==" => ast::BinaryOp::Equal,
    "<>" => ast::BinaryOp::NotEqual,
}

//✅ add-operator :
//✅    "+" | "-" | ".+" | ".-"
AddBinaryOperator : ast::BinaryOp = {
    "+" => ast::BinaryOp::Add,
    "-" => ast::BinaryOp::Sub,
    ".+" => ast::BinaryOp::ElemAdd,
    ".-" => ast::BinaryOp::ElemSub,
}
AddUnaryOperator : ast::UnaryOp = {
    "-" => ast::UnaryOp::Negative,
}

FactorOperator : ast::BinaryOp = {
    "^" => ast::BinaryOp::Exp,
    ".^" => ast::BinaryOp::ElemExp,
}

//✅ mul-operator :
//✅    "*" | "/" | ".*" | "./"
MulOperator : ast::BinaryOp = {
    "*" => ast::BinaryOp::Mul,
    "/" => ast::BinaryOp::Div,
    ".*" => ast::BinaryOp::ElemMul,
    "./" => ast::BinaryOp::ElemDiv,
}

FuncKeyword: String = {
    <"der"> => String::from("der"),
    // <"initial"> => String::from("initial"),
    // <"pure"> => String::from("pure"),
};

ExpressionSimple: ast::Expression = {
//✅ simple-expression :
//✅    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
    #[precedence(level="11")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> ":" <rhs:ExpressionSimple> <right: @R> => {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op: ast::BinaryOp::Range,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ logical-expression :
//✅    logical-term { or logical-term }
    #[precedence(level="10")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> "or" <rhs:ExpressionSimple> <right: @R> => {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op: ast::BinaryOp::Or,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ logical-term :
//✅    logical-factor { and logical-factor }
    #[precedence(level="9")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> "and" <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op: ast::BinaryOp::Add,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ logical-factor :
//✅    [ not ] relation
    #[precedence(level="8")]
    <left: @L> "not" <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Unary(ast::Unary {
            node_data: NodeData::new(id, left, right),
            op: ast::UnaryOp::Not,
            rhs: Box::new(rhs),
        })
    },
//✅ relation :
//✅    arithmetic-expression [ relational-operator arithmetic-expression ]
    #[precedence(level="7")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op:RelationalOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ arithmetic-expression :
//✅    [ add-operator ] term { add-operator term }
    #[precedence(level="6")] #[assoc(side="right")]
    <left: @L> <op:AddUnaryOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Unary(ast::Unary {
            node_data: NodeData::new(id, left, right),
            op,
            rhs: Box::new(rhs),
        })
    },
    #[precedence(level="5")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op:AddBinaryOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ term :
//✅    factor { mul-operator factor }
    #[precedence(level="4")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op: MulOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ factor :
//✅    primary [ ( "^" | ".^" ) primary ]
    #[precedence(level="3")] #[assoc(side="left")]
    <left: @L> <lhs:ExpressionSimple> <op:FactorOperator> <rhs:ExpressionSimple> <right: @R>=> {
        let id = context.new_id();
        ast::Expression::Binary(ast::Binary {
            node_data: NodeData::new(id, left, right),
            op,
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
        })
    },
//✅ primary :
//✅    UNSIGNED-NUMBER
//🟥    | STRING
//✅    | false
//✅    | true
//✅    | ( component-reference
//✅        | der
//✅        | initial
//✅        | pure ) function-call-args
//✅    | component-reference
//🟥    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//🟥    | "[" expression-list { ";" expression-list } "]"
//🟥    | "{" array-arguments "}"
//🟥    | end
    #[precedence(level="0")]
    <left: @L> "(" <rhs:ParenthesisExpression> ")" <right: @R> => {
        let id = context.new_id();
        ast::Expression::Unary(ast::Unary {
            node_data: NodeData::new(id, left, right),
            op: ast::UnaryOp::Paren,
            rhs: Box::new(rhs),
        })
    },
    <left: @L> "{" <args:SeparatedList<Expression, ",">> "}" <right: @R> => {
        let id = context.new_id();
        ast::Expression::Array(ast::Array {
            node_data: NodeData::new(id, left, right),
            args
        })
    },
    <left: @L> <val:"UNSIGNED-INTEGER"> <right: @R> => {
        let id = context.new_id();
        ast::Expression::UnsignedInteger(ast::UnsignedInteger {
            node_data: NodeData::new(id, left, right),
            val,
        })
    },
    <left: @L> <val:"UNSIGNED-REAL"> <right: @R> => {
        let id = context.new_id();
        ast::Expression::UnsignedReal(ast::UnsignedReal {
            node_data: NodeData::new(id, left, right),
            val,
        })
    },
    <left: @L> <val:"boolean"> <right: @R> => {
        let id = context.new_id();
        ast::Expression::Boolean(ast::Boolean {
            node_data: NodeData::new(id, left, right),
            val,
        })
    },
    <comp:ComponentReference> => {
        ast::Expression::Ref(comp)
    },
    #[precedence(level="1")]
    <left: @L> <comp:ComponentReference> <args:FunctionCallArguments> <right: @R> => {
        let id = context.new_id();
        ast::Expression::FunctionCall(ast::FunctionCall {
            node_data: NodeData::new(id, left, right),
            comp,
            args,
        })
    },
    <left: @L> <func: FuncKeyword> <args:FunctionCallArguments> <right: @R> => {
        let id = context.new_id();
        ast::Expression::FunctionCall(ast::FunctionCall {
            node_data: NodeData::new(id, left, right),
            comp: ast::ComponentReference{
                node_data: NodeData::new(context.new_id(), left, right),
                local: false,
                parts: vec![ast::RefPart{
                    node_data: NodeData::new(context.new_id(), left, right),
                    name: func,
                    array_subscripts: Vec::new(),
                }]
            },
            args,
        })
    },
}

//✅ UNSIGNED-NUMBER :
//✅    UNSIGNED-INTEGER | UNSIGNED-REAL
// NOTE: flattened in primary

//✅ type-specifier :
//✅    ["."] name
pub TypeSpecifier: ast::TypeSpecifier = {
    <left: @L> <local: "."?> <name: Name> <right: @R> => {
        let id = context.new_id();
        ast::TypeSpecifier{
            local: local.is_some(),
            name,
        }
    },
}

//✅ name :
//✅    IDENT { "." IDENT }
pub Name: ast::Name = {
    <first:IDENT> <remaining: ("." <IDENT>)*> => {
        let mut v = vec![first];
        v.extend(remaining);
        ast::Name {
            parts: v
        }
    }
}

//✅ component-reference :
//✅    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
pub ComponentReference: ast::ComponentReference = {
    <left: @L> <local: "."?> <parts: SeparatedListMinOne<RefPart, ".">> <right: @R> => {
        let id = context.new_id();
        ast::ComponentReference{
            node_data: NodeData::new(id, left, right),
            local: local.is_some(),
            parts,
        }
    },
}
pub RefPart: ast::RefPart = {
    <left: @L> <name:IDENT> <array_subscripts:ArraySubscripts?> <right: @R> => {
        let id = context.new_id();
        ast::RefPart {
            node_data: NodeData::new(id, left, right),
            name,
            array_subscripts: array_subscripts.unwrap_or(Vec::new()),
        }
    }
}

//🟥 result-reference :
//🟥    component-reference
//🟥    | der "(" component-reference [ "," UNSIGNED-INTEGER ] ")"

//✅ function-call-args :
//✅    "(" [ function-arguments ] ")"
pub FunctionCallArguments: Vec<ast::Expression> = {
    <left: @L> "(" <args:SeparatedList<Expression, ",">> ")" <right: @R> => {
        args
    }
}

//🟥 function-arguments :
//🟥    expression [ "," function-arguments-non-first | for for-indices ]
//🟥    | function-partial-application [ "," function-arguments-non-first ]
//🟥    | named-arguments

//🟥 function-arguments-non-first :
//🟥    function-argument [ "," function-arguments-non-first ]
//🟥    | named-arguments

//🟥 array-arguments :
//🟥    expression [ "," array-arguments-non-first | for for-indices ]

//🟥 array-arguments-non-first :
//🟥    expression [ "," array-arguments-non-first ]

//🟥 named-arguments: named-argument [ "," named-arguments ]

//🟥 named-argument: IDENT "=" function-argument

//🟥 function-argument :
//🟥    function-partial-application | expression

//🟥 function-partial-application :
//🟥    function type-specifier "(" [ named-arguments ] ")"

//🟥 output-expression-list :
//🟥    [ expression ] { "," [ expression ] }

//🟥 expression-list :
//🟥    expression { "," expression }

//✅ array-subscripts :
//✅    "[" subscript { "," subscript } "]"
pub ArraySubscripts: Vec<ast::Subscript> = {
    "[" <subscripts: SeparatedList<Subscript, ",">> "]" => {
        subscripts
    }
}
//✅ subscript :
//✅    ":" | expression
pub Subscript: ast::Subscript = {
    <sub: SubscriptRange> => ast::Subscript::Range(sub),
    <sub: Expression> => ast::Subscript::Expression(sub),
}

pub SubscriptRange: ast::SubscriptRange = {
    <left: @L> ":" <right: @R> => {
        let id = context.new_id();
        ast::SubscriptRange {
            node_data: NodeData::new(id, left, right),
        }
    },
}

//✅ description :
//✅    description-string [ annotation-clause ]
pub Description: Option<ast::Description> = {
    <left: @L> <description_string: DescriptionString>
    <annotation: AnnotationClause?> <right: @R>
    => {
        if left == right {
            None
        } else {
            let id = context.new_id();
            Some(ast::Description {
                node_data: NodeData::new(id, left, right),
                strings: description_string.parts,
                annotation: annotation.unwrap_or(Vec::new()),
            })
        }
    },
}

//✅ description-string :
//✅    [ STRING { "+" STRING } ]
pub DescriptionString: ast::DescriptionString = {
    <s:DescriptionStringPart?> => {
        ast::DescriptionString {
            parts: s.unwrap_or(Vec::new())
        }
    }
}
// Note: LALRPOP doesn't like empty expressions here, so
// adding level of indirection with DescriptionStringPart
DescriptionStringPart: Vec<String> = {
    <first:"STRING"> <remaining: ("+" <"STRING">)*> => {
        let mut v = vec![first];
        v.extend(remaining);
        v
    }
}

//✅ annotation-clause :
//✅    annotation class-modification
pub AnnotationClause: Vec<ast::Argument> = {
    "annotation" <modification:ModificationClass> => {
        modification
    },
}
